#include <iostream>
#include <string.h>
using namespace std;

template <class T>
class Stack
{
    private:
     int size;
     int top;
     T *st;
    
    public:
     Stack()
     {
         size=10;
         top=-1;
         st = new T[size];
     }
     
     Stack(int size)
     {
         this->size = size;
         top = -1;
         st = new T[this->size];
     }
     
     void Push(T x);
     T Pop();
     T Peek(int index);
     T StackTop();
     int isFull();
     int isEmpty(); 
     void Display();
     int isOperand(T x);
     int Prec(T x);
     T *Convert(T * infix);
     int Evaluate(char * postfix);
};

template<class T>
void Stack<T>::Push(T x)
{
    if(isFull())
    {
        cout<<"Stack is Full";
    }
    else
    {
        top++;
        st[top] = x;
    }
}

template<class T>
T Stack<T>::Pop()
{
    T x=-1;
    if(isEmpty())
    {
        cout<<"Stack Underflow";
    }
    else
    {
        x = st[top];
        top--;
    }
    return x;
}


template<class T>
T Stack<T>::Peek(int index)
{
    T x = -1;
    if(top - index + 1 < 0)
    {
        cout<<"Invalid Index";
    }
    else
    {
        x=st[top - index + 1];
    }
    return x;
}

template<class T>
T Stack<T>::StackTop()
{
    T x=-1;
    if(isEmpty())
    {
        cout<<"Stack is Empty";
    }
    else
    {
        x= st[top];
    }
    return x;
}

template<class T>
int Stack<T>::isFull()
{
    if(top==size-1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

template<class T>
int Stack<T>::isEmpty()
{
    if(top==-1)
    {
        return 1;
    }
    else
    {
        return 0; 
    }
    
}

template<class T>
void Stack<T>::Display()
{
    for(int i = top; i>=0; i--)
    {
        cout<<st[i]<<" ";
    }
    cout<<endl;
}


template<class T>
int Stack<T>::isOperand(T x)
{
    if (x == '+' || x == '-' || x == '*' || x == '/')
      return 0;
    else 
      return 1;
    
}

template<class T>
int Stack<T>::Prec(T x)
{
    if (x == '+' || x == '-')
      return 1;
    else if (x == '*' || x == '/') 
      return 2;
    return 0;
}

template<class T>
T* Stack<T>::Convert(T * infix)
{
    T *postfix = new T(20);
    int i=0, j=0;
    
    while(infix[i]!='\0')
    {
        if(isOperand(infix[i]))
        {
            postfix[j++]=infix[i++];
        }
        else
        {
            if(Prec(infix[i]) > Prec(top))
            {
                Push(infix[i++]);
            }
            else
            {
                postfix[j++]=Pop();
            }
        }
    }
    
    while(!isEmpty())
    {
        postfix[j++]=Pop();
    }
    postfix[j]='\0';
    return postfix;
}

template<class T>
int Stack<T>::Evaluate(char * postfix)
{
    int i, x1,x2,r;
    
    for(i=0; postfix[i]!='\0'; i++)
    {
        if (isOperand(postfix[i]))
        {
            Push(postfix[i]-'0');
        }
        else
        {
            x2=Pop();
            x1=Pop();
            
            switch(postfix[i])
            {
                case '+': 
                 r = x1 + x2;
                 Push(r);
                 break;
                case '-': 
                 r = x1 - x2;
                 Push(r);
                 break;
                case '*': 
                 r = x1 * x2;
                 Push(r);
                 break;
                case '/': 
                 r = x1 / x2;
                 Push(r);
                 break;
            }
        }
    }
    
    return Pop();
}
 

int main()
{
    char *infix = "4+1*3/3";
    Stack<char> s1(25);

    char *postfix = s1.Convert(infix);
    
    cout<<postfix<<endl;
    
    Stack<int> s2(25);
    cout<<s2.Evaluate(postfix);
    
}
